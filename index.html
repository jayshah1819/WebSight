<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebSight Profiler</title>
    <script>
        // Disable profiler auto-launch in UI window (this is the dashboard, not the app)
        window.__webSightDisableAutoUI = true;
        window.__webSightIsUIWindow = true;
    </script>
    <script src="profiler-standalone.js?v=6"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Courier New', monospace; 
            background: #fff; 
            color: #000; 
            padding: 20px;
            font-size: 16px;
            line-height: 1.6;
        }
        .container { max-width: 1800px; margin: 0 auto; }
        h1 { font-size: 32px; margin-bottom: 20px; font-weight: bold; }
        h2 { font-size: 24px; margin-bottom: 15px; font-weight: bold; border-bottom: 2px solid #000; padding-bottom: 5px; }
        
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        
        .box { 
            border: 2px solid #000; 
            padding: 20px; 
            background: #fff;
        }
        
        .graph-container { 
            min-height: 400px; 
            position: relative;
        }
        
        .legend {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #fff;
            border: 2px solid #000;
            padding: 10px;
            font-size: 14px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-box {
            width: 25px;
            height: 15px;
            margin-right: 10px;
            border: 1px solid #000;
        }
        
        .stats { margin-bottom: 20px; }
        .stat-row { 
            display: flex; 
            justify-content: space-between; 
            padding: 10px 0;
            border-bottom: 1px solid #ddd;
            font-size: 18px;
        }
        
        .dispatch-item {
            border: 2px solid #ddd;
            padding: 15px;
            margin-bottom: 10px;
            font-size: 16px;
            line-height: 1.8;
        }
        
        .dispatch-item strong {
            font-size: 18px;
            display: block;
            margin-bottom: 8px;
        }
        
        .kernel-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .kernel-box {
            border: 2px solid #000;
            padding: 15px;
        }
        
        .kernel-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 20px;
            border-bottom: 1px solid #000;
            padding-bottom: 5px;
        }
        
        .kernel-box div {
            font-size: 16px;
            margin: 5px 0;
        }
        
        #profiler-status {
            padding: 20px;
            margin-bottom: 20px;
            border: 3px solid #000;
            background: #f0f0f0;
            font-size: 18px;
        }
        
        #profiler-status strong {
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WebSight <span style="font-size: 20px; color: #666; font-weight: normal; font-style: italic;">— Detect GPU performance regressions in WebGPU</span></h1>
        
        <div id="profiler-status">
            Status: <span id="status-text">Waiting for WebGPU app...</span><br>
            Timing Mode: <span id="timing-mode">Unknown</span><br>
            Dispatches: <span id="dispatch-count">0</span><br>
            <div style="margin-top: 10px;">
                <button id="profiler-toggle-btn" onclick="toggleProfiling()" style="padding: 8px 15px; border: 2px solid #000; background: #00aa00; color: #fff; cursor: pointer; font-family: 'Courier New'; font-size: 13px; font-weight: bold; margin-right: 10px;">■ Stop Profiling</button>
                <button onclick="clearProfilingData()" style="padding: 8px 15px; border: 2px solid #000; background: #fff; cursor: pointer; font-family: 'Courier New'; font-size: 13px;">Clear Data</button>
            </div>
        </div>

        <!-- Summary Statistics Box -->
        <div class="box" style="margin-bottom: 15px; background: #f8f8f8; padding: 15px;">
            <h2 style="margin-top: 0; font-size: 20px; margin-bottom: 12px;">Summary Statistics</h2>
            <div class="grid-3" style="gap: 15px;">
                <div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 3px;">Total GPU Time</div>
                    <div id="total-gpu-time" style="font-size: 20px; font-weight: bold; color: #00aa00;">0.00 ms</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 3px;">Total CPU Time</div>
                    <div id="total-cpu-time" style="font-size: 20px; font-weight: bold; color: #000;">0.00 ms</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 3px;">Total Kernel Time</div>
                    <div id="total-kernel-time" style="font-size: 20px; font-weight: bold; color: #0066cc;">0.00 ms</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 3px;">Total Buffer Size</div>
                    <div id="total-buffer-size" style="font-size: 20px; font-weight: bold; color: #ff6600;">0 B</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 3px;">Atomic Contention</div>
                    <div id="atomic-contention" style="font-size: 20px; font-weight: bold; color: #cc0000;">N/A</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 3px;">Total Dispatches</div>
                    <div id="total-dispatches" style="font-size: 20px; font-weight: bold; color: #9900cc;">0</div>
                </div>
            </div>
        </div>

        <!-- Main Performance Graphs -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 2px solid #000; padding-bottom: 5px;">
            <h2 style="margin: 0; border-bottom: none; padding-bottom: 0;">Performance Metrics</h2>
            
            <!-- Inline Graph Settings -->
            <div style="display: flex; gap: 15px; align-items: center; font-size: 12px;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <label style="color: #666;">Line:</label>
                    <select id="line-shape" style="font-size: 12px; padding: 3px 6px; border: 1px solid #000; background: #fff; font-family: 'Courier New', monospace;">
                        <option value="linear" selected>Linear</option>
                        <option value="spline">Smooth</option>
                        <option value="hv">Step-H</option>
                        <option value="vh">Step-V</option>
                    </select>
                </div>
                <div id="smoothing-control" style="display: none; align-items: center; gap: 5px;">
                    <label style="color: #666;">Smooth:</label>
                    <input type="range" id="smoothing" min="0" max="2" step="0.1" value="1.3" style="width: 80px;">
                    <span id="smoothing-value" style="min-width: 25px; color: #666;">1.3</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <label style="color: #666;">Scale:</label>
                    <select id="scale-type" style="font-size: 12px; padding: 3px 6px; border: 1px solid #000; background: #fff; font-family: 'Courier New', monospace;">
                        <option value="log" selected>Log</option>
                        <option value="linear">Linear</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="grid-2">
            <div class="box">
                <div class="graph-container">
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-box" style="background: #00aa00;"></div>
                            <span>GPU</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-box" style="background: #000;"></div>
                            <span>CPU</span>
                        </div>
                    </div>
                    <div id="bandwidth-graph"></div>
                </div>
            </div>
            <div class="box">
                <div class="graph-container">
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-box" style="background: #00aa00;"></div>
                            <span>GPU</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-box" style="background: #000;"></div>
                            <span>CPU</span>
                        </div>
                    </div>
                    <div id="time-graph"></div>
                </div>
            </div>
        </div>

        <!-- Buffer Analysis -->
        <h2>Buffer Analysis</h2>
        <div class="grid-2">
            <div class="box">
                <h2>Buffer Sizes</h2>
                <div style="position: relative; margin-bottom: 8px; display: flex; gap: 15px; font-size: 12px;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 20px; height: 12px; background: #0066cc; border: 1px solid #000;"></div>
                        <span>Input</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 20px; height: 12px; background: #ff6600; border: 1px solid #000;"></div>
                        <span>Output</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 20px; height: 12px; background: #cc0000; border: 1px solid #000;"></div>
                        <span>Atomic</span>
                    </div>
                </div>
                <div id="buffer-size-graph" style="height: 180px;"></div>
            </div>
            <div class="box">
                <h2>Atomic Contention</h2>
                <div id="atomic-graph" style="height: 180px;"></div>
            </div>
        </div>

        <!-- Dispatches and Kernels -->
        <h2>Execution Details</h2>
        <div class="grid-2">
            <div class="box">
                <h2>Dispatches</h2>
                <div id="dispatch-list" style="max-height: 400px; overflow-y: auto;"></div>
            </div>
            <div class="box">
                <h2>Kernel Performance</h2>
                <div id="kernel-list" style="max-height: 400px; overflow-y: auto;"></div>
            </div>
        </div>

        <!-- Kernel Timing Graphs (Dynamic) -->
        <div id="kernel-graphs"></div>

        <!-- Advanced Analysis Section -->
        <h2>Advanced Analysis</h2>
        <div class="grid-3">
            <div class="box">
                <h2>Memory Leaks</h2>
                <div id="memory-analysis" style="font-size: 14px;">
                    <button onclick="runMemoryAnalysis()" style="padding: 10px 15px; border: 2px solid #000; background: #fff; cursor: pointer; font-family: 'Courier New'; font-size: 14px; margin-bottom: 10px;">Run Analysis</button>
                    <div id="memory-results"></div>
                </div>
            </div>
            <div class="box">
                <h2>Workgroup Optimization</h2>
                <div id="workgroup-analysis" style="font-size: 14px;">
                    <div style="color: #666; margin-bottom: 10px; font-size: 12px;">Live warnings appear below automatically</div>
                    <div id="workgroup-results"></div>
                </div>
            </div>
            <div class="box">
                <h2>Shader Complexity</h2>
                <div id="shader-analysis" style="font-size: 14px;">
                    <button onclick="runShaderAnalysis()" style="padding: 10px 15px; border: 2px solid #000; background: #fff; cursor: pointer; font-family: 'Courier New'; font-size: 14px; margin-bottom: 10px;">Run Analysis</button>
                    <div id="shader-results"></div>
                </div>
            </div>
        </div>

        <!-- Test & Validation Section -->
        <h2>Testing & Validation</h2>
        <div class="grid-2">
            <div class="box">
                <h2>Run Tests</h2>
                <button onclick="runTests()" style="padding: 10px 15px; border: 2px solid #000; background: #fff; cursor: pointer; font-family: 'Courier New'; font-size: 14px; margin-bottom: 10px;">Run Test Suite</button>
                <button onclick="validateWebSight()" style="padding: 10px 15px; border: 2px solid #000; background: #fff; cursor: pointer; font-family: 'Courier New'; font-size: 14px; margin-bottom: 10px; margin-left: 10px;">Validate Features</button>
                <div id="test-results" style="font-size: 12px; max-height: 300px; overflow-y: auto; white-space: pre-wrap; font-family: monospace;"></div>
            </div>
            <div class="box">
                <h2>Run Demo</h2>
                <button onclick="runDemo()" style="padding: 10px 15px; border: 2px solid #000; background: #fff; cursor: pointer; font-family: 'Courier New'; font-size: 14px; margin-bottom: 10px;">Run WebGPU Demo</button>
                <button onclick="showFullReport()" style="padding: 10px 15px; border: 2px solid #000; background: #fff; cursor: pointer; font-family: 'Courier New'; font-size: 14px; margin-bottom: 10px; margin-left: 10px;">Full Report</button>
                <div id="demo-results" style="font-size: 12px; max-height: 300px; overflow-y: auto;"></div>
            </div>
        </div>
    </div>

    <!-- Optional test/validation scripts - comment out if not available -->
    <!-- <script src="test.js"></script> -->
    <!-- <script src="validation.js"></script> -->
    <script>
        const profilerChannel = new BroadcastChannel('websight-profiler');

        // Respond to ping to indicate UI is alive
        profilerChannel.addEventListener('message', (event) => {
            if (event.data.type === 'ping') {
                profilerChannel.postMessage({ type: 'pong' });
            }
        });

        // Graph settings - default to linear for accurate performance data
        let graphSettings = {
            lineShape: 'linear',
            smoothing: 1.3,
            scaleType: 'log'
        };

        // Setup event listeners for graph controls
        document.getElementById('line-shape').addEventListener('change', (e) => {
            graphSettings.lineShape = e.target.value;
            // Show/hide smoothing control based on line shape
            document.getElementById('smoothing-control').style.display = 
                e.target.value === 'spline' ? 'flex' : 'none';
            updateUI();
        });

        document.getElementById('smoothing').addEventListener('input', (e) => {
            graphSettings.smoothing = parseFloat(e.target.value);
            document.getElementById('smoothing-value').textContent = e.target.value;
            updateUI();
        });

        document.getElementById('scale-type').addEventListener('change', (e) => {
            graphSettings.scaleType = e.target.value;
            updateUI();
        });

        // Don't use setInterval - only update when broadcast messages arrive
        // This prevents constant UI flickering during benchmarks
        // setInterval(updateUI, 3000);
        
        // Profiler control functions
        let profilingEnabled = true;
        
        function toggleProfiling() {
            profilingEnabled = !profilingEnabled;
            const btn = document.getElementById('profiler-toggle-btn');
            
            if (profilingEnabled) {
                btn.textContent = '■ Stop Profiling';
                btn.style.background = '#00aa00';
                // Send message to enable profiling
                profilerChannel.postMessage({ type: 'enable-profiling' });
            } else {
                btn.textContent = '▶ Start Profiling';
                btn.style.background = '#cc0000';
                // Send message to disable profiling
                profilerChannel.postMessage({ type: 'disable-profiling' });
            }
        }
        
        function clearProfilingData() {
            if (confirm('Clear all profiling data? This cannot be undone.')) {
                // Send message to clear data
                profilerChannel.postMessage({ type: 'clear-data' });
                
                // Also clear local UI data if WebSight is available
                if (typeof WebSight !== 'undefined') {
                    const data = WebSight.getData();
                    data.dispatches = [];
                    data.pipelines = {};
                    data.buffers = {};
                    data.kernels = {};
                    data.logs = [];
                }
                
                updateUI();
            }
        }

        let lastReceivedData = null; // Store last received data for GPU characteristics

        profilerChannel.onmessage = (event) => {
            if (event.data.type === 'profiler-update') {
                lastReceivedData = event.data.data; // Store for buffer limit checks
                if (typeof WebSight !== 'undefined') {
                    const internalData = WebSight.getData();
                    // Merge incoming data
                    Object.assign(internalData, event.data.data);
                    updateUI(); // Immediately update graphs with new data
                }
            }
        };

        function updateUI() {
            if (typeof WebSight === 'undefined') return;
            
            const data = WebSight.getData();
            const stats = WebSight.getStats();
            
            // Get timing mode from data (broadcast) or fallback
            const timingMode = data.timingMode || 'cpu-only';
            
            document.getElementById('status-text').textContent = 
                data.dispatches.length > 0 ? 'Active' : 'Waiting';
            document.getElementById('timing-mode').textContent = 
                `${timingMode} (GPU timing ${stats.gpuTimedDispatches || 0}/${data.dispatches.length})`;
            document.getElementById('dispatch-count').textContent = 
                `${data.dispatches.length} (${stats.gpuTimedDispatches || 0} with GPU timing)`;
            
            if (data.dispatches.length === 0) return;
            
            // Filter for dispatches with timing data (either GPU or CPU)
            // Check gpuTimeNs (the actual property name) instead of gpuTime
            const dispatches = data.dispatches.filter(d => d.gpuTimeNs > 0 || d.cpuStart);
            
            // Update Summary Statistics
            const allDispatches = data.dispatches;
            
            // Use gpuTimeUs (microseconds) since that's what the profiler stores
            const totalGpuTime = allDispatches.reduce((sum, d) => sum + (d.gpuTimeUs || 0), 0);
            const totalCpuTime = allDispatches.reduce((sum, d) => sum + ((d.cpuEnd || 0) - (d.cpuStart || 0)) * 1000, 0);
            
            // Calculate total kernel time from kernel stats
            let totalKernelTime = 0;
            if (data.kernels && typeof data.kernels === 'object') {
                totalKernelTime = Object.values(data.kernels).reduce((sum, k) => {
                    return sum + (k.stats?.totalTime || 0);
                }, 0);
            }
            
            // Calculate total buffer size (data.buffers might be array or object)
            let totalBufferSize = 0;
            if (data.buffers) {
                if (Array.isArray(data.buffers)) {
                    totalBufferSize = data.buffers.reduce((sum, b) => sum + (b.size || 0), 0);
                } else if (typeof data.buffers === 'object') {
                    totalBufferSize = Object.values(data.buffers).reduce((sum, b) => sum + (b.size || 0), 0);
                }
            }
            
            // Atomic contention is shown in the graph below
            const atomicContention = 'See Graph';
            
            document.getElementById('total-gpu-time').textContent = (totalGpuTime / 1000).toFixed(2) + ' ms';
            document.getElementById('total-cpu-time').textContent = (totalCpuTime / 1000).toFixed(2) + ' ms';
            document.getElementById('total-kernel-time').textContent = (totalKernelTime / 1000000).toFixed(2) + ' ms'; // totalKernelTime is in nanoseconds
            document.getElementById('total-buffer-size').textContent = formatBytes(totalBufferSize);
            document.getElementById('atomic-contention').textContent = atomicContention;
            document.getElementById('total-dispatches').textContent = allDispatches.length;
            
            if (dispatches.length === 0) return;
            
            // Group dispatches by largest data buffer size for bandwidth analysis
            const sizeGroups = new Map();
            
            dispatches.forEach(d => {
                const buffers = d.bufferAccesses || [];
                
                // Filter to data buffers (large buffers or named data/in/out/key/payload)
                const dataBuffers = buffers.filter(b => {
                    const label = (b.label || '').toLowerCase();
                    const size = b.size || 0;
                    return size > 1024 * 1024 || 
                           label.includes('in') || 
                           label.includes('out') || 
                           label.includes('key') ||
                           label.includes('payload') ||
                           label.includes('data') ||
                           label.includes('buffer');
                });
                
                // Use largest data buffer as proxy for working set size
                const largestBuffer = dataBuffers.length > 0 
                    ? Math.max(...dataBuffers.map(b => b.size || 0))
                    : (buffers.length > 0 ? Math.max(...buffers.map(b => b.size || 0)) : 0);
                
                if (!sizeGroups.has(largestBuffer)) {
                    sizeGroups.set(largestBuffer, []);
                }
                sizeGroups.get(largestBuffer).push(d);
            });
            
            // Create data points by summing dispatches with same buffer size
            const dataPoints = [];
            sizeGroups.forEach((dispatches, largestBuffer) => {
                const inputBytes = largestBuffer;
                const inputSizeMB = inputBytes / (1024 * 1024);
                
                // Calculate bytes transferred (read + write)
                const bytesTransferred = largestBuffer * 2;
                
                // Separate GPU and CPU calculations
                const gpuDispatches = dispatches.filter(d => d.timingSource === 'gpu_timestamp');
                const useGpuTiming = gpuDispatches.length > 0;
                
                // Sum times for all dispatches with same buffer size
                const totalGpuTimeNs = useGpuTiming
                    ? gpuDispatches.reduce((sum, d) => sum + (d.gpuTimeNs || 0), 0)
                    : dispatches.reduce((sum, d) => sum + (d.cpuTimeNs || 0), 0);
                
                const totalCpuTimeNs = dispatches.reduce((sum, d) => sum + (d.cpuTimeNs || 0), 0);
                
                // Calculate bandwidth: GB/s = bytesTransferred / time_ns
                const gpuBandwidth = totalGpuTimeNs > 0 ? bytesTransferred / totalGpuTimeNs : 0;
                const cpuBandwidth = totalCpuTimeNs > 0 ? bytesTransferred / totalCpuTimeNs : 0;
                
                // Create two data points (one for GPU, one for CPU)
                dataPoints.push({
                    inputSizeMB,
                    inputBytes,
                    time: totalGpuTimeNs,
                    bandwidth: gpuBandwidth,
                    timing: 'GPU'
                });
                
                dataPoints.push({
                    inputSizeMB,
                    inputBytes,
                    time: totalCpuTimeNs,
                    bandwidth: cpuBandwidth,
                    timing: 'CPU'
                });
            });
            
            // Sort by input size for proper line connections
            dataPoints.sort((a, b) => a.inputBytes - b.inputBytes);
            
            // Separate GPU and CPU data for plotting
            const gpuData = dataPoints.filter(d => d.timing === 'GPU');
            const cpuData = dataPoints.filter(d => d.timing === 'CPU');
            
            const inputSizes = [...new Set(dataPoints.map(d => d.inputSizeMB))].sort((a, b) => a - b);
            const gpuBandwidth = gpuData.map(d => d.bandwidth);
            const cpuBandwidth = cpuData.map(d => d.bandwidth);
            const gpuTimes = gpuData.map(d => d.time / 1000);
            const cpuTimes = cpuData.map(d => d.time / 1000);
            
            // Check if GPU timing is available
            const hasGpuTiming = gpuData.some(d => d.time > 0 && d.time !== cpuData.find(c => c.inputBytes === d.inputBytes)?.time);
            
            // Plot Bandwidth vs Input Size
            const bandwidthTraces = [
                {
                    x: inputSizes,
                    y: gpuBandwidth,
                    name: 'GPU',
                    line: { color: '#00aa00', width: 2 },
                    mode: 'lines+markers'
                }
            ];
            
            // Show CPU bandwidth only if GPU timing unavailable
            if (!hasGpuTiming) {
                bandwidthTraces.push({
                    x: inputSizes,
                    y: cpuBandwidth,
                    name: 'CPU (JS overhead)',
                    line: { color: '#666666', width: 1, dash: 'dot' },
                    mode: 'lines+markers'
                });
            }
            
            plotGraph('bandwidth-graph', bandwidthTraces, 'Input Size (MB)', 'Bandwidth (GB/s)');
            
            // Plot Time vs Input Size
            const timeTraces = [
                {
                    x: inputSizes,
                    y: gpuTimes,
                    name: 'GPU',
                    line: { color: '#00aa00', width: 2 },
                    mode: 'lines+markers'
                }
            ];
            
            if (!hasGpuTiming) {
                timeTraces.push({
                    x: inputSizes,
                    y: cpuTimes,
                    name: 'CPU (JS overhead)',
                    line: { color: '#666666', width: 1, dash: 'dot' },
                    mode: 'lines+markers'
                });
            }
            
            plotGraph('time-graph', timeTraces, 'Input Size (MB)', 'Time (μs)');
            
            // Buffer Size Graph
            plotBufferSizes(data.buffers);
            
            // Atomic Contention Graph
            plotAtomicContention(dispatches);
            
            updateDispatchList(data.dispatches);
            
            updateKernelList(data.kernels);
            
            updateKernelGraphs(data);
            
            // Update workgroup summary automatically
            updateWorkgroupSummary(data.dispatches);
        }
        
        function updateWorkgroupSummary(dispatches) {
            if (!dispatches || dispatches.length === 0) {
                return;
            }
            
            const resultsDiv = document.getElementById('workgroup-results');
            
            // Group by pipeline and workgroup config
            const configGroups = new Map();
            
            dispatches.forEach(d => {
                // IMPORTANT: Show ALL dispatches, not just those with occupancy analysis
                // Skip only if we have neither analysis nor dimension violation
                if (!d.occupancyAnalysis && !d.dimensionViolation) {
                    return;
                }
                
                const key = `${d.pipelineLabel}|${d.workgroupSize.join('x')}`;
                if (!configGroups.has(key)) {
                    configGroups.set(key, {
                        pipeline: d.pipelineLabel || 'compute_pipeline',
                        workgroupSize: d.workgroupSize,
                        dispatchSize: d.dispatchSize,
                        analysis: d.occupancyAnalysis || { score: 0, issues: [] },
                        count: 0,
                        dimensionViolation: false
                    });
                }
                const group = configGroups.get(key);
                group.count++;
                if (d.dimensionViolation) {
                    group.dimensionViolation = true;
                }
            });
            
            if (configGroups.size === 0) {
                resultsDiv.innerHTML = '<div style="margin-top: 10px; color: #666;">No workgroup analysis data yet. Run benchmarks first.</div>';
                return;
            }
            
            // Create summary table
            let html = '<div style="margin-top: 10px; font-family: \'Courier New\', monospace; font-size: 12px;">';
            html += '<table style="width: 100%; border-collapse: collapse; border: 2px solid #000;">';
            html += '<tr style="background: #000; color: #fff; font-weight: bold;">';
            html += '<th style="padding: 8px; border: 1px solid #000; text-align: left;">Pipeline</th>';
            html += '<th style="padding: 8px; border: 1px solid #000; text-align: center;">Workgroup Size</th>';
            html += '<th style="padding: 8px; border: 1px solid #000; text-align: center;">Dispatch Size</th>';
            html += '<th style="padding: 8px; border: 1px solid #000; text-align: center;">Utilization</th>';
            html += '<th style="padding: 8px; border: 1px solid #000; text-align: center;">Score</th>';
            html += '<th style="padding: 8px; border: 1px solid #000; text-align: center;">Status</th>';
            html += '<th style="padding: 8px; border: 1px solid #000; text-align: left;">Issues</th>';
            html += '</tr>';
            
            const sortedGroups = Array.from(configGroups.values()).sort((a, b) => a.analysis.score - b.analysis.score);
            
            sortedGroups.forEach(group => {
                const score = group.analysis.score;
                const scoreColor = score >= 80 ? '#00aa00' : score >= 60 ? '#ff8800' : '#cc0000';
                const statusText = group.dimensionViolation ? 'FAILED' : score >= 80 ? 'Good' : score >= 60 ? 'Suboptimal' : 'Poor';
                const statusColor = group.dimensionViolation ? '#cc0000' : scoreColor;
                
                html += '<tr style="border: 1px solid #ccc;">';
                html += `<td style="padding: 8px; border: 1px solid #ccc; font-size: 10px;">${group.pipeline}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ccc; text-align: center; font-weight: bold;">${group.workgroupSize.join(' × ')}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ccc; text-align: center;">${group.dispatchSize.join(' × ')}</td>`;
                
                // Show workgroup utilization
                if (group.analysis.workgroupUtilization) {
                    const util = group.analysis.workgroupUtilization;
                    
                    // Use explicit flags if available, otherwise calculate
                    const xExceeds = util.xExceeds !== undefined ? util.xExceeds : (util.xDim > util.maxPerDim);
                    const yExceeds = util.yExceeds !== undefined ? util.yExceeds : (util.yDim > util.maxPerDim);
                    const zExceeds = util.zExceeds !== undefined ? util.zExceeds : (util.zDim > util.maxPerDim);
                    const anyExceeds = xExceeds || yExceeds || zExceeds;
                    
                    const utilizationColor = anyExceeds ? '#cc0000' : '#666';
                    html += `<td style="padding: 8px; border: 1px solid #ccc; text-align: center; font-size: 10px; color: ${utilizationColor};">`;
                    html += `<strong>${util.total.toLocaleString()} WGs</strong><br>`;
                    html += `<span style="color: ${xExceeds ? '#cc0000' : '#666'}; ${xExceeds ? 'font-weight: bold;' : ''}">X: ${util.xPercent}%${xExceeds ? ' EXCEEDS!' : ''}</span>`;
                    if (util.yDim > 1) html += `<br><span style="color: ${yExceeds ? '#cc0000' : '#666'}; ${yExceeds ? 'font-weight: bold;' : ''}">Y: ${util.yPercent}%${yExceeds ? ' EXCEEDS!' : ''}</span>`;
                    if (util.zDim > 1) html += `<br><span style="color: ${zExceeds ? '#cc0000' : '#666'}; ${zExceeds ? 'font-weight: bold;' : ''}">Z: ${util.zPercent}%${zExceeds ? ' EXCEEDS!' : ''}</span>`;
                    html += '</td>';
                } else {
                    html += `<td style="padding: 8px; border: 1px solid #ccc; text-align: center; color: #999;">—</td>`;
                }
                
                html += `<td style="padding: 8px; border: 1px solid #ccc; text-align: center; font-weight: bold; color: ${scoreColor};">${score}/100</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ccc; text-align: center; font-weight: bold; color: ${statusColor};">${statusText}</td>`;
                html += `<td style="padding: 8px; border: 1px solid #ccc; font-size: 10px;">`;
                
                // Show dimension violations first and most prominently
                const criticalIssues = group.analysis.issues.filter(i => i.severity === 'critical');
                const otherIssues = group.analysis.issues.filter(i => i.severity !== 'critical');
                
                if (criticalIssues.length > 0) {
                    criticalIssues.forEach(issue => {
                        html += `<strong style="color: #cc0000;">• ${issue.message}</strong><br>`;
                    });
                }
                
                if (group.dimensionViolation && criticalIssues.length === 0) {
                    html += '<strong style="color: #cc0000;">• DISPATCH EXCEEDS GPU LIMIT</strong><br>';
                }
                
                // Show other issues (non-critical)
                const displayIssues = otherIssues.slice(0, 2);
                displayIssues.forEach(issue => {
                    html += `• ${issue.message}<br>`;
                });
                
                html += '</td>';
                html += '</tr>';
            });
            
            html += '</table>';
            
            // Summary stats
            const totalConfigs = configGroups.size;
            const goodConfigs = sortedGroups.filter(g => g.analysis.score >= 80 && !g.dimensionViolation).length;
            const failedConfigs = sortedGroups.filter(g => g.dimensionViolation).length;
            
            html += '<div style="margin-top: 12px; padding: 10px; border: 2px solid #000; background: #f5f5f5;">';
            html += `<strong>Summary:</strong> ${totalConfigs} configuration${totalConfigs > 1 ? 's' : ''} analyzed | `;
            html += `<span style="color: #00aa00;">${goodConfigs} optimized</span> | `;
            if (failedConfigs > 0) {
                html += `<span style="color: #cc0000;">${failedConfigs} FAILED</span>`;
            } else {
                html += `<span style="color: #666;">0 failed</span>`;
            }
            html += '</div>';
            
            resultsDiv.innerHTML = html;
        }

        // Helper function to format large numbers (1B, 1M, 1K, etc.)
        function formatBytes(bytes) {
            if (bytes >= 1e9) return (bytes / 1e9).toFixed(1) + 'B';
            if (bytes >= 1e6) return (bytes / 1e6).toFixed(1) + 'M';
            if (bytes >= 1e3) return (bytes / 1e3).toFixed(1) + 'K';
            return bytes.toString();
        }

        function plotGraph(divId, traces, xLabel, yLabel) {
            const layout = {
                xaxis: {
                    title: { text: xLabel, font: { size: 11 } },
                    type: 'linear',
                    gridcolor: '#e0e0e0',
                    showline: true,
                    linecolor: '#000',
                    linewidth: 1,
                    showgrid: true,
                    zeroline: false,
                    tickfont: { size: 9 },
                    autorange: true
                },
                yaxis: {
                    title: { text: yLabel, font: { size: 11 } },
                    type: 'log',
                    gridcolor: '#e0e0e0',
                    showline: true,
                    linecolor: '#000',
                    linewidth: 1,
                    showgrid: true,
                    zeroline: false,
                    tickfont: { size: 9 },
                    exponentformat: 'power',
                    autorange: true
                },
                showlegend: true,
                legend: {
                    x: 1,
                    xanchor: 'right',
                    y: 1,
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#000',
                    borderwidth: 1,
                    font: { size: 9 }
                },
                margin: { l: 70, r: 20, t: 20, b: 60 },
                plot_bgcolor: '#fff',
                paper_bgcolor: '#fff',
                font: { family: 'Courier New', size: 10 }
            };
            
            // Use Plotly.react for smoother updates instead of newPlot
            const plotData = traces.map(t => ({
                x: t.x,
                y: t.y,
                type: 'scatter',
                mode: 'lines+markers',
                marker: { 
                    size: 4, 
                    color: t.line.color 
                },
                line: { 
                    width: 2, 
                    color: t.line.color
                },
                name: t.name
            }));
            
            Plotly.react(divId, plotData, layout, {
                displayModeBar: false,
                responsive: true
            });
        }

        function plotBufferSizes(buffers) {
            const bufferArray = Object.values(buffers);
            if (bufferArray.length === 0) {
                document.getElementById('buffer-size-graph').innerHTML = '<div style="padding:20px;">No buffers tracked</div>';
                return;
            }
            
            // Get max buffer size from GPU characteristics (typically 2GB or 4GB)
            const maxBufferSize = lastReceivedData?.gpuCharacteristics?.limits?.maxBufferSize || (2 * 1024 * 1024 * 1024); // Default 2GB
            const maxBufferSizeMB = maxBufferSize / (1024 * 1024);
            const warningThreshold = maxBufferSize * 0.9; // Warn at 90% of max
            
            const input = [], output = [], atomic = [], uniform = [], labels = [];
            const warnings = []; // Track buffers near limit
            
            bufferArray.forEach((b, i) => {
                const label = b.label || `Buffer ${i}`;
                labels.push(label);
                const sizeKB = b.size / 1024; // Use KB for display
                
                // Check if buffer is near max size
                if (b.size >= warningThreshold) {
                    const percentOfMax = ((b.size / maxBufferSize) * 100).toFixed(1);
                    warnings.push({ label, size: b.size, percentOfMax });
                }
                
                // Categorize by label name (most reliable indicator)
                const labelLower = (b.label || '').toLowerCase();
                
                if (labelLower.includes('atomic')) {
                    atomic.push(sizeKB);
                    input.push(0);
                    output.push(0);
                    uniform.push(0);
                } else if (labelLower.includes('uniform')) {
                    uniform.push(sizeKB);
                    input.push(0);
                    output.push(0);
                    atomic.push(0);
                } else if (labelLower.includes('output') || labelLower.includes('result') || labelLower.includes('dst')) {
                    output.push(sizeKB);
                    input.push(0);
                    atomic.push(0);
                    uniform.push(0);
                } else {
                    // Default to input
                    input.push(sizeKB);
                    output.push(0);
                    atomic.push(0);
                    uniform.push(0);
                }
            });
            
            const traces = [
                { x: labels, y: input, name: 'Input', type: 'bar', marker: { color: '#0066cc' } },
                { x: labels, y: output, name: 'Output', type: 'bar', marker: { color: '#ff6600' } },
                { x: labels, y: atomic, name: 'Atomic', type: 'bar', marker: { color: '#cc0000' } },
                { x: labels, y: uniform, name: 'Uniform', type: 'bar', marker: { color: '#9933ff' } }
            ];
            
            Plotly.newPlot('buffer-size-graph', traces, {
                barmode: 'stack',
                showlegend: true,
                legend: {
                    x: 1,
                    xanchor: 'right',
                    y: 1,
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#000',
                    borderwidth: 1,
                    font: { size: 9 }
                },
                xaxis: { title: '', tickangle: -45, tickfont: { size: 9 } },
                yaxis: { title: 'Size (KB)', type: 'log', tickfont: { size: 9 } },
                margin: { l: 60, r: 20, t: 20, b: 100 },
                font: { family: 'Courier New', size: 10 }
            }, { displayModeBar: false, responsive: true });
            
            // Add warnings for buffers near max size
            if (warnings.length > 0) {
                let warningHtml = '<div style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 2px solid #ff8800; border-radius: 4px; font-size: 11px;">';
                warningHtml += '<strong style="color: #ff8800;">Buffer Size Warnings:</strong><br>';
                warnings.forEach(w => {
                    const sizeMB = (w.size / (1024 * 1024)).toFixed(2);
                    warningHtml += `• <strong>${w.label}</strong>: ${sizeMB} MB (${w.percentOfMax}% of max ${maxBufferSizeMB.toFixed(0)} MB)<br>`;
                });
                warningHtml += '<span style="color: #666; font-size: 10px;">Buffers exceeding 90% of GPU max buffer size may cause allocation failures.</span>';
                warningHtml += '</div>';
                document.getElementById('buffer-size-graph').insertAdjacentHTML('afterend', warningHtml);
            }
        }

        function plotAtomicContention(dispatches) {
            const x = [], y = [];
            
            dispatches.forEach((d, i) => {
                const buffers = d.bufferAccesses || [];
                
                // Look for potential atomic buffers (small buffers with relevant names)
                const atomicBuffers = buffers.filter(b => {
                    const label = (b.label || '').toLowerCase();
                    const size = b.size || 0;
                    const sizeMB = size / (1024 * 1024);
                    
                    return (label.includes('atomic') || 
                           label.includes('hist') || 
                           label.includes('histogram') ||
                           label.includes('counter')) &&
                           sizeMB < 10;
                });
                
                if (atomicBuffers.length > 0) {
                    // Calculate total threads
                    const dispatchSize = d.dispatchSize || [d.x || 1, d.y || 1, d.z || 1];
                    const workgroupSize = d.workgroupSize || [1, 1, 1];
                    const totalThreads = 
                        dispatchSize[0] * dispatchSize[1] * dispatchSize[2] *
                        workgroupSize[0] * workgroupSize[1] * workgroupSize[2];
                    
                    // Calculate bins from buffer size
                    const bufferSize = atomicBuffers[0].size || 0;
                    const bins = bufferSize / 4;
                    const threadsPerBin = bins > 0 ? totalThreads / bins : 0;
                    
                    if (threadsPerBin > 0) {
                        x.push(i);
                        y.push(threadsPerBin);
                    }
                }
            });
            
            if (x.length === 0) {
                document.getElementById('atomic-graph').innerHTML = 
                    '<div style="padding: 20px; text-align: center; color: #666;">No atomic operations detected</div>';
                return;
            }
            
            Plotly.newPlot('atomic-graph', [{
                x, y, type: 'scatter', mode: 'lines+markers',
                line: { color: '#ff6600', width: 2 }, marker: { size: 4, color: '#ff6600' }
            }], {
                xaxis: { title: 'Dispatch Index' },
                yaxis: { title: 'Threads per Bin' },
                margin: { l: 60, r: 20, t: 20, b: 50 },
                font: { family: 'Courier New', size: 10 }
            }, { displayModeBar: false, responsive: true });
        }

        function updateDispatchList(dispatches) {
            const div = document.getElementById('dispatch-list');
            const recent = dispatches.slice(-20).reverse();
            
            div.innerHTML = recent.map(d => {
                // Use gpuTimeUs (microseconds) which is what the profiler stores
                const gpuTimeDisplay = d.gpuTimeUs && d.timingSource === 'gpu_timestamp'
                    ? `${d.gpuTimeUs.toFixed(2)} μs`
                    : d.cpuTimeUs 
                    ? `${d.cpuTimeUs.toFixed(2)} μs (CPU fallback)`
                    : 'pending';
                
                const cpuTime = d.cpuTimeUs 
                    ? d.cpuTimeUs.toFixed(2)
                    : '0.00';
                
                // Create a better label
                const pipelineLabel = d.pipelineLabel && d.pipelineLabel !== 'unknown' 
                    ? d.pipelineLabel 
                    : 'Unlabeled Pipeline';
                
                // Use passType instead of type
                const dispatchType = d.passType || 'unknown';
                const dispatchTitle = dispatchType === 'draw' 
                    ? `Draw Call #${d.index}`
                    : dispatchType === 'compute'
                    ? `Compute #${d.index}`
                    : `Dispatch #${d.index}`;
                
                // Handle different dispatch types
                const workgroupInfo = dispatchType === 'compute' 
                    ? `Dispatch: ${d.dispatchSize ? d.dispatchSize.join('×') : `${d.x}×${d.y}×${d.z}`} | Workgroup: ${d.workgroupSize ? d.workgroupSize.join('×') : '?'}`
                    : dispatchType === 'draw'
                    ? `Vertices: ${d.vertexCount}, Instances: ${d.instanceCount}`
                    : `Type: ${dispatchType}`;
                
                // Hide if CPU time is too small (just overhead)
                if (d.cpuTimeNs < 100) return ''; // Less than 100ns is just noise
                
                return `
                    <div class="dispatch-item">
                        <strong>${dispatchTitle}</strong><br>
                        Pipeline: ${pipelineLabel}<br>
                        ${workgroupInfo}<br>
                        Time: ${gpuTimeDisplay}
                    </div>
                `;
            }).filter(x => x).join(''); // Filter out empty strings
        }

        function updateKernelList(kernels) {
            const div = document.getElementById('kernel-list');
            const kernelArray = Object.values(kernels);
            
            if (kernelArray.length === 0) {
                div.innerHTML = '<div style="padding: 20px; color: #666;">No kernels detected</div>';
                return;
            }
            
            // Filter out kernels with no meaningful stats
            const meaningfulKernels = kernelArray.filter(k => 
                k.stats && k.stats.count > 0 && k.stats.totalTime > 0
            );
            
            if (meaningfulKernels.length === 0) {
                div.innerHTML = '<div style="padding: 20px; color: #666;">Collecting kernel statistics...</div>';
                return;
            }
            
            div.innerHTML = meaningfulKernels.map((k, idx) => {
                // All kernel stats are in nanoseconds - convert to microseconds and milliseconds
                const avgTime = k.stats.avgTime ? (k.stats.avgTime / 1000).toFixed(2) : 'N/A';
                const totalTime = k.stats.totalTime ? (k.stats.totalTime / 1000000).toFixed(3) : 'N/A';
                const minTime = k.stats.minTime && k.stats.minTime !== Infinity 
                    ? (k.stats.minTime / 1000).toFixed(2) 
                    : 'N/A';
                const maxTime = k.stats.maxTime ? (k.stats.maxTime / 1000).toFixed(2) : 'N/A';
                
                // Get workgroup size
                const wg = k.workgroupSize || [1, 1, 1];
                const wgStr = Array.isArray(wg) 
                    ? wg.join('×') 
                    : `${wg.x || 1}×${wg.y || 1}×${wg.z || 1}`;
                
                // Use label if available
                const kernelName = k.label && k.label.trim() && k.label !== 'compute_pipeline'
                    ? k.label 
                    : `Pipeline #${idx + 1}`;
                
                return `
                    <div class="dispatch-item">
                        <strong>${kernelName}</strong><br>
                        Workgroup: ${wgStr}<br>
                        Calls: ${k.stats.count}<br>
                        Avg: ${avgTime} μs<br>
                        Total: ${totalTime} ms<br>
                        Range: ${minTime} - ${maxTime} μs
                    </div>
                `;
            }).join('');
        }

        function updateKernelGraphs(data) {
            const kernels = Object.values(data.kernels);
            const div = document.getElementById('kernel-graphs');
            
            if (kernels.length === 0) return;
            
            const gridClass = kernels.length <= 2 ? 'grid-2' : 'kernel-grid';
            div.innerHTML = `<h2>Kernel Timing (Per-Dispatch GPU Timestamps)</h2><div class="${gridClass}" id="kernel-grid-container"></div>`;
            
            const container = document.getElementById('kernel-grid-container');
            
            kernels.forEach((kernel, idx) => {
                const dispatches = data.dispatches.filter(d => d.kernelId === kernel.id && d.gpuTime > 0);
                if (dispatches.length === 0) return;
                
                const boxDiv = document.createElement('div');
                boxDiv.className = 'box';
                
                const avgTime = kernel.stats?.avgTime?.toFixed(2) || 'N/A';
                const count = kernel.stats?.count || 0;
                
                // Use label if available, otherwise create a descriptive name
                const kernelName = kernel.label && kernel.label.trim() 
                    ? kernel.label 
                    : `Kernel ${idx + 1}`;
                
                boxDiv.innerHTML = `
                    <div class="kernel-title">${kernelName} (${count} dispatches, avg: ${avgTime} μs)</div>
                    <div id="kernel-graph-${idx}" style="height: 200px;"></div>
                `;
                container.appendChild(boxDiv);
                
                const x = dispatches.map((d, i) => i);
                const y = dispatches.map(d => d.gpuTime);
                
                setTimeout(() => {
                    Plotly.newPlot(`kernel-graph-${idx}`, [{
                        x, y, 
                        type: 'scatter', 
                        mode: 'lines+markers',
                        line: { color: '#00aa00', width: 2 },
                        marker: { size: 4, color: '#00aa00' }
                    }], {
                        xaxis: { title: 'Dispatch #', tickfont: { size: 9 } },
                        yaxis: { title: 'GPU Time (μs)', tickfont: { size: 9 } },
                        margin: { l: 50, r: 20, t: 20, b: 40 },
                        font: { family: 'Courier New', size: 9 },
                        plot_bgcolor: '#fff',
                        paper_bgcolor: '#fff'
                    }, { displayModeBar: false, responsive: true });
                }, 100);
            });
        }

        // Start monitoring
        if (typeof WebSight !== 'undefined') {
            WebSight.start();
        }
        updateUI();

        // Advanced Analysis Functions
        function runMemoryAnalysis() {
            if (typeof WebSight === 'undefined' || typeof WebSight.getMemoryLeaks !== 'function') {
                document.getElementById('memory-results').innerHTML = 
                    '<p style="color: #999;">Memory analysis not available in UI mode. Connect to an active WebGPU application.</p>';
                return;
            }
            const report = WebSight.getMemoryLeaks();
            const div = document.getElementById('memory-results');
            
            const leakCount = report.summary.totalLeaks;
            const activeCount = report.summary.activeResources;
            const currentMem = formatBytes(report.stats.currentMemory);
            const peakMem = formatBytes(report.stats.peakMemory);
            
            div.innerHTML = `
                <div style="margin-top: 10px;">
                    <strong>Status: ${leakCount === 0 ? 'No Leaks' : leakCount + ' Potential Leaks'}</strong><br>
                    Active Resources: ${activeCount}<br>
                    Current Memory: ${currentMem}<br>
                    Peak Memory: ${peakMem}<br>
                    Leak Rate: ${report.summary.leakRate}<br>
                    <br>
                    ${leakCount > 0 ? '<strong>Top Leaks:</strong><br>' + 
                        report.leaks.slice(0, 5).map(l => 
                            `• ${l.type}: ${formatBytes(l.size)} (${formatTime(l.age)})`
                        ).join('<br>') : ''}
                </div>
            `;
        }

        function runWorkgroupAnalysis() {
            if (typeof WebSight === 'undefined' || typeof WebSight.getWorkgroupAnalysis !== 'function') {
                document.getElementById('workgroup-results').innerHTML = 
                    '<p style="color: #999;">Workgroup analysis not available in UI mode. Connect to an active WebGPU application.</p>';
                return;
            }
            const analysis = WebSight.getWorkgroupAnalysis();
            const div = document.getElementById('workgroup-results');
            
            if (!analysis.summary) {
                div.innerHTML = '<div style="margin-top: 10px;">No dispatches to analyze yet.<br>Run some WebGPU code first.</div>';
                return;
            }
            
            const summary = analysis.summary;
            const gradeColor = summary.grade === 'A' ? '#00aa00' : 
                               summary.grade === 'B' ? '#88cc00' :
                               summary.grade === 'C' ? '#ffaa00' : '#cc0000';
            
            div.innerHTML = `
                <div style="margin-top: 10px;">
                    <strong style="color: ${gradeColor};">Grade: ${summary.grade} (${summary.averageScore}/100)</strong><br>
                    Kernels Analyzed: ${summary.totalKernels}<br>
                    Critical Issues: ${summary.criticalIssues}<br>
                    High Priority: ${summary.highIssues}<br>
                    <br>
                    ${summary.needsAttention.length > 0 ? 
                        '<strong>Needs Attention:</strong><br>' +
                        summary.needsAttention.slice(0, 3).map(a => 
                            `• ${a.kernelId}: Score ${a.score}/100`
                        ).join('<br>') : 
                        'All workgroups optimized!'}
                </div>
            `;
        }

        function runShaderAnalysis() {
            if (typeof WebSight === 'undefined' || typeof WebSight.getShaderAnalysis !== 'function') {
                document.getElementById('shader-results').innerHTML = 
                    '<p style="color: #999;">Shader analysis not available in UI mode. Connect to an active WebGPU application.</p>';
                return;
            }
            const analysis = WebSight.getShaderAnalysis();
            const div = document.getElementById('shader-results');
            
            if (!analysis.summary) {
                div.innerHTML = '<div style="margin-top: 10px;">No shaders to analyze yet.<br>Run some WebGPU code first.</div>';
                return;
            }
            
            const summary = analysis.summary;
            const grade = summary.overallGrade;
            const gradeColor = grade.letter === 'A' ? '#00aa00' : 
                               grade.letter === 'B' ? '#88cc00' :
                               grade.letter === 'C' ? '#ffaa00' : '#cc0000';
            
            div.innerHTML = `
                <div style="margin-top: 10px;">
                    <strong style="color: ${gradeColor};">Grade: ${grade.letter} (${summary.averageScore}/100)</strong><br>
                    Shaders Analyzed: ${summary.totalShaders}<br>
                    Avg Complexity: ${summary.averageComplexity}<br>
                    Critical Issues: ${summary.criticalIssues}<br>
                    <br>
                    ${summary.needsOptimization.length > 0 ? 
                        '<strong>Needs Optimization:</strong><br>' +
                        summary.needsOptimization.slice(0, 3).map(a => 
                            `• Score ${a.score}/100: ${a.issues.length} issues`
                        ).join('<br>') : 
                        'All shaders optimized!'}
                </div>
            `;
        }

        async function runTests() {
            const div = document.getElementById('test-results');
            div.innerHTML = 'Running tests...\n';
            
            // Capture console output
            const oldLog = console.log;
            let output = '';
            console.log = function(...args) {
                output += args.join(' ') + '\n';
                oldLog.apply(console, args);
            };
            
            if (typeof runWebSightTests === 'function') {
                await runWebSightTests();
            } else {
                output = 'Test suite not loaded. Make sure test.js is included.';
            }
            
            console.log = oldLog;
            div.innerHTML = output;
        }

        async function validateWebSight() {
            const div = document.getElementById('test-results');
            div.innerHTML = 'Running validation...\n';
            
            // Capture console output
            const oldLog = console.log;
            let output = '';
            console.log = function(...args) {
                output += args.join(' ') + '\n';
                oldLog.apply(console, args);
            };
            
            if (typeof window.validateWebSight === 'function') {
                await window.validateWebSight();
            } else {
                output = ' Validation suite not loaded. Make sure validation.js is included.';
            }
            
            console.log = oldLog;
            div.innerHTML = output;
        }

        async function runDemo() {
            const div = document.getElementById('demo-results');
            div.innerHTML = 'Running demo...<br>';
            
            if (typeof runWebSightDemo === 'function') {
                await runWebSightDemo();
                div.innerHTML += 'Demo completed! Check console for details.<br>';
                div.innerHTML += 'Run analyses above to see results.';
            } else {
                div.innerHTML = 'Demo not loaded. Make sure validation.js is included.';
            }
        }

        function showFullReport() {
            if (typeof WebSight === 'undefined' || typeof WebSight.getFullAnalysisReport !== 'function') {
                document.getElementById('demo-results').innerHTML = 
                    '<p style="color: #999;">Full analysis not available in UI mode. Connect to an active WebGPU application.</p>';
                return;
            }
            const div = document.getElementById('demo-results');
            const report = WebSight.getFullAnalysisReport();
            
            div.innerHTML = `
                <strong>Full Analysis Report</strong><br>
                <br>
                <strong>Memory:</strong><br>
                • Current: ${formatBytes(report.memory.stats.currentMemory)}<br>
                • Peak: ${formatBytes(report.memory.stats.peakMemory)}<br>
                • Leaks: ${report.memory.summary.totalLeaks}<br>
                <br>
                ${report.workgroup ? `
                    <strong>Workgroup:</strong><br>
                    • Grade: ${report.workgroup.grade}<br>
                    • Kernels: ${report.workgroup.totalKernels}<br>
                    • Issues: ${report.workgroup.criticalIssues} critical<br>
                    <br>
                ` : ''}
                ${report.shader ? `
                    <strong>Shader:</strong><br>
                    • Grade: ${report.shader.overallGrade.letter}<br>
                    • Shaders: ${report.shader.totalShaders}<br>
                    • Issues: ${report.shader.criticalIssues} critical<br>
                ` : ''}
            `;
        }

        function formatTime(ms) {
            if (ms < 1000) return ms + 'ms';
            if (ms < 60000) return (ms / 1000).toFixed(1) + 's';
            return (ms / 60000).toFixed(1) + 'min';
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebSight Profiler</title>
    <script src="profiler-standalone.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Courier New', monospace; 
            background: #fff; 
            color: #000; 
            padding: 20px;
            font-size: 16px;
            line-height: 1.6;
        }
        .container { max-width: 1800px; margin: 0 auto; }
        h1 { font-size: 32px; margin-bottom: 20px; font-weight: bold; }
        h2 { font-size: 24px; margin-bottom: 15px; font-weight: bold; border-bottom: 2px solid #000; padding-bottom: 5px; }
        
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        
        .box { 
            border: 2px solid #000; 
            padding: 20px; 
            background: #fff;
        }
        
        .graph-container { 
            min-height: 400px; 
            position: relative;
        }
        
        .legend {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #fff;
            border: 2px solid #000;
            padding: 10px;
            font-size: 14px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-box {
            width: 25px;
            height: 15px;
            margin-right: 10px;
            border: 1px solid #000;
        }
        
        .stats { margin-bottom: 20px; }
        .stat-row { 
            display: flex; 
            justify-content: space-between; 
            padding: 10px 0;
            border-bottom: 1px solid #ddd;
            font-size: 18px;
        }
        
        .dispatch-item {
            border: 2px solid #ddd;
            padding: 15px;
            margin-bottom: 10px;
            font-size: 16px;
            line-height: 1.8;
        }
        
        .dispatch-item strong {
            font-size: 18px;
            display: block;
            margin-bottom: 8px;
        }
        
        .kernel-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        
        .kernel-box {
            border: 2px solid #000;
            padding: 15px;
        }
        
        .kernel-title {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 20px;
            border-bottom: 1px solid #000;
            padding-bottom: 5px;
        }
        
        .kernel-box div {
            font-size: 16px;
            margin: 5px 0;
        }
        
        #profiler-status {
            padding: 20px;
            margin-bottom: 20px;
            border: 3px solid #000;
            background: #f0f0f0;
            font-size: 18px;
        }
        
        #profiler-status strong {
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WebSight <span style="font-size: 20px; color: #666; font-weight: normal; font-style: italic;">— Detect GPU performance regressions in WebGPU</span></h1>
        
        <div id="profiler-status">
            Status: <span id="status-text">Waiting for WebGPU app...</span><br>
            Timing Mode: <span id="timing-mode">Unknown</span><br>
            Dispatches: <span id="dispatch-count">0</span>
        </div>

        <!-- Summary Statistics Box -->
        <div class="box" style="margin-bottom: 15px; background: #f8f8f8; padding: 15px;">
            <h2 style="margin-top: 0; font-size: 20px; margin-bottom: 12px;">Summary Statistics</h2>
            <div class="grid-3" style="gap: 15px;">
                <div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 3px;">Total GPU Time</div>
                    <div id="total-gpu-time" style="font-size: 20px; font-weight: bold; color: #00aa00;">0.00 ms</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 3px;">Total CPU Time</div>
                    <div id="total-cpu-time" style="font-size: 20px; font-weight: bold; color: #000;">0.00 ms</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 3px;">Total Kernel Time</div>
                    <div id="total-kernel-time" style="font-size: 20px; font-weight: bold; color: #0066cc;">0.00 ms</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 3px;">Total Buffer Size</div>
                    <div id="total-buffer-size" style="font-size: 20px; font-weight: bold; color: #ff6600;">0 B</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 3px;">Atomic Contention</div>
                    <div id="atomic-contention" style="font-size: 20px; font-weight: bold; color: #cc0000;">N/A</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 3px;">Total Dispatches</div>
                    <div id="total-dispatches" style="font-size: 20px; font-weight: bold; color: #9900cc;">0</div>
                </div>
            </div>
        </div>

        <!-- Main Performance Graphs -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 2px solid #000; padding-bottom: 5px;">
            <h2 style="margin: 0; border-bottom: none; padding-bottom: 0;">Performance Metrics</h2>
            
            <!-- Inline Graph Settings -->
            <div style="display: flex; gap: 15px; align-items: center; font-size: 12px;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <label style="color: #666;">Line:</label>
                    <select id="line-shape" style="font-size: 12px; padding: 3px 6px; border: 1px solid #000; background: #fff; font-family: 'Courier New', monospace;">
                        <option value="linear">Linear</option>
                        <option value="spline" selected>Smooth</option>
                        <option value="hv">Step-H</option>
                        <option value="vh">Step-V</option>
                    </select>
                </div>
                <div id="smoothing-control" style="display: flex; align-items: center; gap: 5px;">
                    <label style="color: #666;">Smooth:</label>
                    <input type="range" id="smoothing" min="0" max="2" step="0.1" value="1.3" style="width: 80px;">
                    <span id="smoothing-value" style="min-width: 25px; color: #666;">1.3</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <label style="color: #666;">Scale:</label>
                    <select id="scale-type" style="font-size: 12px; padding: 3px 6px; border: 1px solid #000; background: #fff; font-family: 'Courier New', monospace;">
                        <option value="log" selected>Log</option>
                        <option value="linear">Linear</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="grid-2">
            <div class="box">
                <div class="graph-container">
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-box" style="background: #00aa00;"></div>
                            <span>GPU</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-box" style="background: #000;"></div>
                            <span>CPU</span>
                        </div>
                    </div>
                    <div id="bandwidth-graph"></div>
                </div>
            </div>
            <div class="box">
                <div class="graph-container">
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-box" style="background: #00aa00;"></div>
                            <span>GPU</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-box" style="background: #000;"></div>
                            <span>CPU</span>
                        </div>
                    </div>
                    <div id="time-graph"></div>
                </div>
            </div>
        </div>

        <!-- Buffer Analysis -->
        <h2>Buffer Analysis</h2>
        <div class="grid-2">
            <div class="box">
                <h2>Buffer Sizes</h2>
                <div style="position: relative; margin-bottom: 8px; display: flex; gap: 15px; font-size: 12px;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 20px; height: 12px; background: #0066cc; border: 1px solid #000;"></div>
                        <span>Input</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 20px; height: 12px; background: #ff6600; border: 1px solid #000;"></div>
                        <span>Output</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <div style="width: 20px; height: 12px; background: #cc0000; border: 1px solid #000;"></div>
                        <span>Atomic</span>
                    </div>
                </div>
                <div id="buffer-size-graph" style="height: 180px;"></div>
            </div>
            <div class="box">
                <h2>Atomic Contention</h2>
                <div id="atomic-graph" style="height: 180px;"></div>
            </div>
        </div>

        <!-- Dispatches and Kernels -->
        <h2>Execution Details</h2>
        <div class="grid-2">
            <div class="box">
                <h2>Dispatches</h2>
                <div id="dispatch-list" style="max-height: 400px; overflow-y: auto;"></div>
            </div>
            <div class="box">
                <h2>Kernel Performance</h2>
                <div id="kernel-list" style="max-height: 400px; overflow-y: auto;"></div>
            </div>
        </div>

        <!-- Kernel Timing Graphs (Dynamic) -->
        <div id="kernel-graphs"></div>
    </div>

    <script>
        const profilerChannel = new BroadcastChannel('websight-profiler');

        // Graph settings
        let graphSettings = {
            lineShape: 'spline',
            smoothing: 1.3,
            scaleType: 'log'
        };

        // Setup event listeners for graph controls
        document.getElementById('line-shape').addEventListener('change', (e) => {
            graphSettings.lineShape = e.target.value;
            // Show/hide smoothing control based on line shape
            document.getElementById('smoothing-control').style.display = 
                e.target.value === 'spline' ? 'flex' : 'none';
            updateUI();
        });

        document.getElementById('smoothing').addEventListener('input', (e) => {
            graphSettings.smoothing = parseFloat(e.target.value);
            document.getElementById('smoothing-value').textContent = e.target.value;
            updateUI();
        });

        document.getElementById('scale-type').addEventListener('change', (e) => {
            graphSettings.scaleType = e.target.value;
            updateUI();
        });

        // Update UI every second
        setInterval(updateUI, 1000);

        profilerChannel.onmessage = (event) => {
            if (event.data.type === 'profiler-update') {
                if (typeof WebSight !== 'undefined') {
                    const internalData = WebSight.getData();
                    Object.assign(internalData, event.data.data);
                }
            }
        };

        function updateUI() {
            if (typeof WebSight === 'undefined') return;
            
            const data = WebSight.getData();
            const stats = WebSight.getStats();
            const sessionInfo = WebSight.getSessionInfo();
            
            document.getElementById('status-text').textContent = 
                data.dispatches.length > 0 ? 'Active' : 'Waiting';
            document.getElementById('timing-mode').textContent = 
                `${sessionInfo.timingMode} (${sessionInfo.timestampCount}/${sessionInfo.maxTimestamps} slots)`;
            document.getElementById('dispatch-count').textContent = 
                `${data.dispatches.length} (${stats.dispatchesWithTiming} with GPU timing)`;
            
            if (data.dispatches.length === 0) return;
            
            const dispatches = data.dispatches.filter(d => d.gpuTime > 0);
            
            // Update Summary Statistics
            const allDispatches = data.dispatches;
            const totalGpuTime = allDispatches.reduce((sum, d) => sum + (d.gpuTime || 0), 0);
            const totalCpuTime = allDispatches.reduce((sum, d) => sum + ((d.cpuEnd || 0) - (d.cpuStart || 0)) * 1000, 0);
            
            // Calculate total kernel time from kernel stats
            let totalKernelTime = 0;
            if (data.kernels && typeof data.kernels === 'object') {
                totalKernelTime = Object.values(data.kernels).reduce((sum, k) => {
                    return sum + (k.stats?.totalTime || 0);
                }, 0);
            }
            
            // Calculate total buffer size (data.buffers might be array or object)
            let totalBufferSize = 0;
            if (data.buffers) {
                if (Array.isArray(data.buffers)) {
                    totalBufferSize = data.buffers.reduce((sum, b) => sum + (b.size || 0), 0);
                } else if (typeof data.buffers === 'object') {
                    totalBufferSize = Object.values(data.buffers).reduce((sum, b) => sum + (b.size || 0), 0);
                }
            }
            
            // Check for atomic contention (if any kernel has atomic operations)
            let hasAtomics = false;
            let atomicContention = 'None';
            for (const dispatch of allDispatches) {
                if (dispatch.atomicOps && dispatch.atomicOps > 0) {
                    hasAtomics = true;
                    // Simple heuristic: high atomic ops relative to work items suggests contention
                    const workItems = (dispatch.workgroupSize?.[0] || 1) * (dispatch.workgroupSize?.[1] || 1) * (dispatch.workgroupSize?.[2] || 1);
                    if (dispatch.atomicOps > workItems * 0.5) {
                        atomicContention = 'High';
                        break;
                    } else if (dispatch.atomicOps > workItems * 0.1) {
                        atomicContention = 'Medium';
                    } else if (atomicContention === 'None') {
                        atomicContention = 'Low';
                    }
                }
            }
            if (!hasAtomics) atomicContention = 'N/A';
            
            document.getElementById('total-gpu-time').textContent = (totalGpuTime / 1000).toFixed(2) + ' ms';
            document.getElementById('total-cpu-time').textContent = (totalCpuTime / 1000).toFixed(2) + ' ms';
            document.getElementById('total-kernel-time').textContent = (totalKernelTime / 1000).toFixed(2) + ' ms';
            document.getElementById('total-buffer-size').textContent = formatBytes(totalBufferSize);
            document.getElementById('atomic-contention').textContent = atomicContention;
            document.getElementById('total-dispatches').textContent = allDispatches.length;
            
            // Set color based on contention level
            const contentionEl = document.getElementById('atomic-contention');
            if (atomicContention === 'High') contentionEl.style.color = '#cc0000';
            else if (atomicContention === 'Medium') contentionEl.style.color = '#ff8800';
            else if (atomicContention === 'Low') contentionEl.style.color = '#00aa00';
            else contentionEl.style.color = '#666';
            
            if (dispatches.length === 0) return;
            
            const inputBytes = dispatches.map(d => {
                const buffers = d.bufferAccesses || [];
                const totalBytes = buffers.reduce((sum, b) => sum + (b.size || 0), 0);
                return totalBytes > 0 ? totalBytes : 1024;
            });
            
            const gpuTimes = dispatches.map(d => d.gpuTime);
            const cpuTimes = dispatches.map(d => ((d.cpuEnd || 0) - (d.cpuStart || 0)) * 1000);
            
            const gpuBandwidth = dispatches.map((d, i) => {
                const bytes = inputBytes[i];
                const timeSeconds = gpuTimes[i] / 1e6;
                return timeSeconds > 0 ? (bytes / timeSeconds) / 1e9 : 0;
            });
            
            const cpuBandwidth = dispatches.map((d, i) => {
                const bytes = inputBytes[i];
                const timeSeconds = cpuTimes[i] / 1e6;
                return timeSeconds > 0 ? (bytes / timeSeconds) / 1e9 : 0;
            });
            
            // Sort data by input size to ensure lines connect properly
            const sortedIndices = inputBytes.map((_, i) => i).sort((a, b) => inputBytes[a] - inputBytes[b]);
            const sortedInputBytes = sortedIndices.map(i => inputBytes[i]);
            const sortedGpuBandwidth = sortedIndices.map(i => gpuBandwidth[i]);
            const sortedCpuBandwidth = sortedIndices.map(i => cpuBandwidth[i]);
            const sortedGpuTimes = sortedIndices.map(i => gpuTimes[i]);
            const sortedCpuTimes = sortedIndices.map(i => cpuTimes[i]);
            
            // Plot Bandwidth
            plotGraph('bandwidth-graph', 
                [
                    {
                        x: sortedInputBytes,
                        y: sortedGpuBandwidth,
                        name: 'GPU',
                        line: { color: '#00aa00', width: 2 }
                    },
                    {
                        x: sortedInputBytes,
                        y: sortedCpuBandwidth,
                        name: 'CPU',
                        line: { color: '#000000', width: 2 }
                    }
                ],
                'Input array size (bytes)',
                'Achieved bandwidth (GB/s)'
            );
            
            // Plot Time
            plotGraph('time-graph',
                [
                    {
                        x: sortedInputBytes,
                        y: sortedGpuTimes,
                        name: 'GPU',
                        line: { color: '#00aa00', width: 2 }
                    },
                    {
                        x: sortedInputBytes,
                        y: sortedCpuTimes,
                        name: 'CPU',
                        line: { color: '#000000', width: 2 }
                    }
                ],
                'Input array size (bytes)',
                'Time (μs)'
            );
            
            // Buffer Size Graph
            plotBufferSizes(data.buffers);
            
            // Atomic Contention Graph
            plotAtomicContention(dispatches);
            
            updateDispatchList(data.dispatches);
            
            updateKernelList(data.kernels);
            
            updateKernelGraphs(data);
        }

        // Helper function to format large numbers (1B, 1M, 1K, etc.)
        function formatBytes(bytes) {
            if (bytes >= 1e9) return (bytes / 1e9).toFixed(1) + 'B';
            if (bytes >= 1e6) return (bytes / 1e6).toFixed(1) + 'M';
            if (bytes >= 1e3) return (bytes / 1e3).toFixed(1) + 'K';
            return bytes.toString();
        }

        function plotGraph(divId, traces, xLabel, yLabel) {
            // Filter out zero/invalid values for better visualization
            const cleanedTraces = traces.map(t => {
                const validIndices = t.y.map((v, i) => v > 0 && t.x[i] > 0 ? i : -1).filter(i => i !== -1);
                return {
                    x: validIndices.map(i => t.x[i]),
                    y: validIndices.map(i => t.y[i]),
                    name: t.name,
                    line: t.line,
                    marker: { color: t.line.color }
                };
            });

            const layout = {
                xaxis: {
                    title: { text: xLabel, font: { size: 11 } },
                    type: graphSettings.scaleType,
                    gridcolor: '#e0e0e0',
                    showline: true,
                    linecolor: '#000',
                    linewidth: 1,
                    showgrid: true,
                    zeroline: false,
                    tickfont: { size: 9 },
                    tickformat: '',
                    tickvals: null,
                    ticktext: null,
                    exponentformat: 'none',
                    autorange: true
                },
                yaxis: {
                    title: { text: yLabel, font: { size: 11 } },
                    type: graphSettings.scaleType,
                    gridcolor: '#e0e0e0',
                    showline: true,
                    linecolor: '#000',
                    linewidth: 1,
                    showgrid: true,
                    zeroline: false,
                    tickfont: { size: 9 },
                    exponentformat: 'power',
                    autorange: true
                },
                showlegend: true,
                legend: {
                    x: 1,
                    xanchor: 'right',
                    y: 1,
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#000',
                    borderwidth: 1,
                    font: { size: 9 }
                },
                margin: { l: 70, r: 20, t: 20, b: 60 },
                plot_bgcolor: '#fff',
                paper_bgcolor: '#fff',
                font: { family: 'Courier New', size: 10 }
            };
            
            // Create custom tick values and labels for x-axis
            if (cleanedTraces.length > 0 && cleanedTraces[0].x.length > 0) {
                const allX = cleanedTraces.flatMap(t => t.x);
                const minX = Math.min(...allX);
                const maxX = Math.max(...allX);
                
                // Generate logarithmic tick values
                const logMin = Math.floor(Math.log10(minX));
                const logMax = Math.ceil(Math.log10(maxX));
                const tickvals = [];
                const ticktext = [];
                
                for (let exp = logMin; exp <= logMax; exp++) {
                    const base = Math.pow(10, exp);
                    // Add major ticks (1, 10, 100, etc.)
                    if (base >= minX && base <= maxX) {
                        tickvals.push(base);
                        ticktext.push(formatBytes(base));
                    }
                    // Add minor ticks (2, 5, 20, 50, etc.)
                    for (let mult of [2, 5]) {
                        const val = base * mult;
                        if (val >= minX && val <= maxX) {
                            tickvals.push(val);
                            ticktext.push(formatBytes(val));
                        }
                    }
                }
                
                layout.xaxis.tickvals = tickvals;
                layout.xaxis.ticktext = ticktext;
            }
            
            // Use Plotly.react for smoother updates instead of newPlot
            const plotData = cleanedTraces.map(t => {
                const lineConfig = {
                    width: 2,
                    color: t.line.color,
                    shape: graphSettings.lineShape
                };
                
                // Only add smoothing for spline shape
                if (graphSettings.lineShape === 'spline') {
                    lineConfig.smoothing = graphSettings.smoothing;
                }
                
                return {
                    x: t.x,
                    y: t.y,
                    type: 'scatter',
                    mode: 'lines+markers',
                    marker: { size: 6, color: t.line.color },
                    line: lineConfig,
                    name: t.name,
                    connectgaps: false
                };
            });
            
            Plotly.react(divId, plotData, layout, {
                displayModeBar: false,
                responsive: true
            });
        }

        function plotBufferSizes(buffers) {
            const bufferArray = Object.values(buffers);
            if (bufferArray.length === 0) {
                document.getElementById('buffer-size-graph').innerHTML = '<div style="padding:20px;">No buffers</div>';
                return;
            }
            
            const input = [], output = [], atomic = [], labels = [];
            
            bufferArray.forEach((b, i) => {
                labels.push(b.label || `Buffer ${i}`);
                const sizeMB = b.size / (1024 * 1024);
                const isInput = (b.usage & 0x0080) && (b.usage & 0x0008);
                const isOutput = (b.usage & 0x0080) && (b.usage & 0x0004);
                const isAtomic = b.label.toLowerCase().includes('atomic');
                
                input.push(isInput && !isAtomic ? sizeMB : 0);
                output.push(isOutput && !isAtomic ? sizeMB : 0);
                atomic.push(isAtomic ? sizeMB : 0);
            });
            
            const traces = [
                { x: labels, y: input, name: 'Input', type: 'bar', marker: { color: '#0066cc' } },
                { x: labels, y: output, name: 'Output', type: 'bar', marker: { color: '#ff6600' } },
                { x: labels, y: atomic, name: 'Atomic', type: 'bar', marker: { color: '#cc0000' } }
            ];
            
            Plotly.newPlot('buffer-size-graph', traces, {
                barmode: 'stack',
                showlegend: false,
                xaxis: { title: 'Buffer', tickangle: -45 },
                yaxis: { title: 'Size (MB)' },
                margin: { l: 50, r: 20, t: 20, b: 100 },
                font: { family: 'Courier New', size: 9 }
            }, { displayModeBar: false, responsive: true });
        }

        function plotAtomicContention(dispatches) {
            const x = [], y = [];
            
            dispatches.forEach((d, i) => {
                const atomicBuffers = (d.bufferAccesses || []).filter(b => 
                    b.label && b.label.toLowerCase().includes('atomic')
                );
                
                if (atomicBuffers.length > 0) {
                    const totalThreads = d.x * d.y * d.z;
                    const bins = atomicBuffers[0].size / 4;
                    x.push(i);
                    y.push(totalThreads / bins);
                }
            });
            
            if (x.length === 0) {
                document.getElementById('atomic-graph').innerHTML = 
                    '<div style="padding: 20px; text-align: center; color: #666;">No atomic operations detected</div>';
                return;
            }
            
            Plotly.newPlot('atomic-graph', [{
                x, y, type: 'scatter', mode: 'lines+markers',
                line: { color: '#ff6600', width: 2 }, marker: { size: 4, color: '#ff6600' }
            }], {
                xaxis: { title: 'Dispatch Index' },
                yaxis: { title: 'Threads per Bin' },
                margin: { l: 60, r: 20, t: 20, b: 50 },
                font: { family: 'Courier New', size: 10 }
            }, { displayModeBar: false, responsive: true });
        }

        function updateDispatchList(dispatches) {
            const div = document.getElementById('dispatch-list');
            const recent = dispatches.slice(-20).reverse();
            
            div.innerHTML = recent.map(d => {
                const gpuTimeDisplay = d.gpuTime 
                    ? `${d.gpuTime.toFixed(2)} μs (${(d.gpuTime / 1000).toFixed(3)} ms)`
                    : 'pending';
                const cpuTime = d.cpuEnd && d.cpuStart 
                    ? ((d.cpuEnd - d.cpuStart) * 1000).toFixed(2) 
                    : 'N/A';
                
                return `
                    <div class="dispatch-item">
                        <strong>Dispatch ${d.index}</strong>: ${d.pipelineLabel}<br>
                        Workgroups: ${d.x}×${d.y}×${d.z}<br>
                        GPU Time: ${gpuTimeDisplay}<br>
                        CPU Time: ${cpuTime} μs<br>
                        Source: ${d.timingSource || 'unknown'}<br>
                        Timestamps: [${d.timestampStart}, ${d.timestampEnd}]
                    </div>
                `;
            }).join('');
        }

        function updateKernelList(kernels) {
            const div = document.getElementById('kernel-list');
            const kernelArray = Object.values(kernels);
            
            if (kernelArray.length === 0) {
                div.innerHTML = '<div style="padding: 20px; color: #666;">No kernels detected</div>';
                return;
            }
            
            div.innerHTML = kernelArray.map(k => {
                const avgTime = k.stats?.avgTime ? k.stats.avgTime.toFixed(2) : 'N/A';
                const totalTime = k.stats?.totalTime ? (k.stats.totalTime / 1000).toFixed(3) : 'N/A';
                const minTime = k.stats?.minTime ? k.stats.minTime.toFixed(2) : 'N/A';
                const maxTime = k.stats?.maxTime ? k.stats.maxTime.toFixed(2) : 'N/A';
                const wg = k.workgroupSize || { x: 0, y: 0, z: 0 };
                
                return `
                    <div class="dispatch-item">
                        <strong>${k.label}</strong><br>
                        Workgroup: ${wg.x}×${wg.y}×${wg.z}<br>
                        Dispatches: ${k.stats?.count || 0}<br>
                        Avg: ${avgTime} μs<br>
                        Total: ${totalTime} ms<br>
                        Range: ${minTime} - ${maxTime} μs
                    </div>
                `;
            }).join('');
        }

        function updateKernelGraphs(data) {
            const kernels = Object.values(data.kernels);
            const div = document.getElementById('kernel-graphs');
            
            if (kernels.length === 0) return;
            
            const gridClass = kernels.length <= 2 ? 'grid-2' : 'kernel-grid';
            div.innerHTML = `<h2>Kernel Timing (Per-Dispatch GPU Timestamps)</h2><div class="${gridClass}" id="kernel-grid-container"></div>`;
            
            const container = document.getElementById('kernel-grid-container');
            
            kernels.forEach((kernel, idx) => {
                const dispatches = data.dispatches.filter(d => d.kernelId === kernel.id && d.gpuTime > 0);
                if (dispatches.length === 0) return;
                
                const boxDiv = document.createElement('div');
                boxDiv.className = 'box';
                
                const avgTime = kernel.stats?.avgTime?.toFixed(2) || 'N/A';
                const count = kernel.stats?.count || 0;
                
                boxDiv.innerHTML = `
                    <div class="kernel-title">${kernel.label} (${count} dispatches, avg: ${avgTime} μs)</div>
                    <div id="kernel-graph-${idx}" style="height: 200px;"></div>
                `;
                container.appendChild(boxDiv);
                
                const x = dispatches.map((d, i) => i);
                const y = dispatches.map(d => d.gpuTime);
                
                setTimeout(() => {
                    Plotly.newPlot(`kernel-graph-${idx}`, [{
                        x, y, 
                        type: 'scatter', 
                        mode: 'lines+markers',
                        line: { color: '#00aa00', width: 2 },
                        marker: { size: 4, color: '#00aa00' }
                    }], {
                        xaxis: { title: 'Dispatch #', tickfont: { size: 9 } },
                        yaxis: { title: 'GPU Time (μs)', tickfont: { size: 9 } },
                        margin: { l: 50, r: 20, t: 20, b: 40 },
                        font: { family: 'Courier New', size: 9 },
                        plot_bgcolor: '#fff',
                        paper_bgcolor: '#fff'
                    }, { displayModeBar: false, responsive: true });
                }, 100);
            });
        }

        // Start monitoring
        if (typeof WebSight !== 'undefined') {
            WebSight.start();
        }
        updateUI();
    </script>
</body>
</html>
